# 总体分析

Redis是一种快速的键值存储，支持复杂的聚合数据类型

> 例如，键可以绑定到具有许多元素，集合的列表，
子字典（哈希）等。


1. 容错能力。某些节点可能会脱机而不会影响操作。
2. 无需使用具有大量RAM的单个盒子即可容纳更大的数据集。
3. 扩展写入。

> 单个Redis实例每秒可以支持`140,000`次操作


## 网络布局

- 一个或多个数据节点。每个节点都由`ip：port`标识。
- 单个配置节点。
- 另外一个代理节点（`redis-cluster`节点）。
- 单个处理节点。

数据节点和配置节点只是普通的`redis`服务器实例。

## 配置节点

- 包含有关群集中所有数据节点的信息。
- 包含有关群集中所有代理节点的信息。
- 包含有关哪些数据节点拥有键的给定子空间的信息。

键空间分为`1024`个不同的`散列槽`。
（1024只是一个示例，此值应该是可配置的）

给定键，执行`SHA1`（key）并使用结果的后10位获得代表“键槽”的10位数字（从0到1023）。

配置节点将密钥空间的每个插槽映射到M个不同的数据节点（每个密钥都存储在M个节点中，可配置）。

可以一次由单个客户端修改`配置`节点。

1. 锁定是使用SETNX执行的。

2. 应该复制配置节点，因为整个网络只有一个配置节点。
3. 它是系统的唯一单点故障。
4. 当配置节点发生故障时，群集不会停止运行，但不会停止运行
5. 能够在出现某些异常情况（例如数据）时恢复
6. 节点脱机或向群集添加了新的数据节点。

7. 与其他所有Data节点一样，Configuration节点是标准的Redis服务器。

数据节点
==========

数据节点仅保存数据，并且是正常的Redis进程。节点上没有存储任何配置，集群中的节点也不是“活动的”，它们只是接收普通的Redis命令。

代理节点
===========

代理节点从客户端获取请求，并将此请求路由到正确的Redis节点。

代理节点与所有数据节点和配置节点。

1. 该连接会随着时间的流逝而保持PING请求
2. 如果没有流量，则要计时。这样代理节点可以尽快理解
3. 在某些数据节点或配置节点中存在问题。

--------

1. 启动代理节点时，它需要知道配置节点地址，以便加载有关数据节点以及密钥空间与节点之间的映射的信息。

2. 在启动时，代理节点还将在`Configuration`节点中注册自己，并确保每`N`秒（通过`EXPIREING`密钥）刷新其配置，以便可以检测到代理节点何时发生故障。

3. 客户端可以向任何代理节点提交查询，因此设计良好的客户端可能会询问启动时，查询配置节点的代理节点列表。那如果查询针对给定的代理节点失败，可以针对下一个重试。

4. 代理节点还负责向配置节点发信号通知失败的数据节点，以便处理节点可以采取适当的措施。

5. 当新的数据节点加入或离开群集时，以及通常在群集配置更改时，所有代理节点都会收到通知，并会从 **配置** 节点重新加载配置。

代理节点-如何提交查询
=====================================

这是查询的处理方式：

1）客户端使用Redis协议将查询发送到代理节点，就像它是普通的Redis节点一样。
2）代理节点检查命令参数以检测密钥。密钥是散列的。代理节点具有将给定密钥映射到M个节点的表，以及到所有节点的持久连接的表。

在这一点上，读写查询的过程有所不同：

### 写查询：

1. 代理节点将查询同时转发到M个数据节点，等待答复。
2. 一旦收到所有答复，代理节点就会检查答复是否一致。
    例如，所有M个节点都需要以OK进行回复，依此类推。如果查询在节点的子集中失败，但在其他节点成功，则认为失败的节点不可靠，并离线通知配置节点。
3. 答复被转回给客户。

###　读查询：

代理节点将查询转发给单个随机客户端，并将回复传递回客户端。

处理节点
=============

处理节点是具有以下角色的特殊Redis客户端：

1. 处理存储在Config节点中的群集配置。
2. 负责从网络中动态添加和删除节点。
3. 重新定位节点添加/删除上的键。
4. 向代理节点发送配置更改信号。

有关哈希槽的更多详细信息
===========================

`配置` 节点以以下形式保存1024个密钥：

```
    哈希槽：0
    哈希槽：1
    ...
    哈希槽：1023
```

每个哈希槽实际上是一个`Redis`列表，包含一个或多个`ip：port`对。例如：

 `hashingslot：10 => 192.168.1.19:6379，192.168.1.200:6379`

这意味着散列到插槽10的密钥将保存在两个数据节点`192.168.1.19:6379`和`192.168.1.200:6379`中。

当客户端（通过代理节点）执行读取操作时，代理将联系给定插槽的负责数据节点中的随机`Data`节点。

## 示例

例如，客户端可以要求对给定的代理节点执行以下操作：

1. 取得`mykey`
2. `mykey`散列到（例如）插槽10，因此代理会将请求转发到数据节点`192.168.1.19:6379`或`192.168.1.200:6379`，然后将答复转发回客户端。
3. 执行写操作时，它将被转发到示例中的两个`Data`节点（以及通常转发到所有数据节点）。

添加或删除节点
========================

将数据节点添加到群集后，它通过`LPUSH`操作被添加到`Redis列表`中，该列表代表准备进入群集的数据节点队列。

1. 该列表当然由`配置`节点保存，可以手动添加或通过配置实用程序添加。

    `LPUSH`新节点`192.168.1.55:6379`

2. 处理节点将不时检查 `newode` 列表中的此新元素。
3. 如果有新的节点等待进入集群，则以这种方式一个接一个地处理它们：

### 示例

例如，假设集群中已经有两个数据节点：

    192.168.1.1:6379
    192.168.1.2:6379

我们通过`LPUSH`操作添加了一个新节点`192.168.1.3:6379`。

我们可以想象在两个初始节点之间平均分配`1024`个哈希槽。

为了添加新的（第三个）节点，我们要做的是将`341`个插槽从两个旧服务器逐渐移至新服务器。

到目前为止，可以认为每个哈希槽仅存储在单个服务器中，以便稍后将其推广。

> 为了简化实现，可以将每个插槽阻塞的方式从一个数据节点移动到另一个数据节点，也就是说，读取操作将继续到所有`1024`个插槽

> >但是一次只有一个插槽将延迟写入操作，直到移动为止从一个数据节点到另一个数据节点的操作已完成。

为此，在移动给定节点之前，`Handler`节点在配置服务器中将其标记为 **写锁定**，然后要求所有`Proxy节点`刷新配置。

然后移动插槽（所有键的`1/1024`）。修改配置服务器以反映新的哈希插槽配置，解锁插槽，通知代理节点。